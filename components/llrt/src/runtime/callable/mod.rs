use std::future::Future;

use log::debug;
use tokio::task;

use crate::get_tokio_rt;
use crate::runtime::engine::types::*;
use crate::runtime::engine::*;

/// A JsCallable is the data structure used to represent a function in LLRT
/// that is callable from JavaScript. It contains the Rust function pointer,
/// and the function's name. Note that privileges are handled by the HLRT.
pub struct JsCallable {
    /// The name of the function, as it will appear in JavaScript.
    pub name: &'static str,

    /// The function pointer.
    pub func: fn(Invocation) -> JsResult<JsValue>,
}

impl JsCallable {
    pub const fn new(name: &'static str, func: fn(Invocation) -> JsResult<JsValue>) -> Self {
        Self { name, func }
    }
}

pub fn register_all(engine: &JsEngine, dest: &JsObject) -> JsResult<()> {
    for callable in inventory::iter::<JsCallable> {
        dest.set(callable.name, engine.create_function(callable.func))?;
    }

    Ok(())
}

/// Internal call, used by the shim generated by #[js_callable] for async functions.
#[doc(hidden)]
pub fn execute_async<F>(
    inv: Invocation,
    func: impl Fn(Invocation) -> F + 'static,
) -> JsResult<JsValue>
where
    F: Future<Output = JsResult<JsValue>>,
{
    debug!("execute_async: enter");
    let engine = inv.engine.clone();
    let promise = engine.create_promise();
    let rt = get_tokio_rt();
    let _ = rt.enter();

    debug!("execute_async: spawning task");

    let owned_promise = promise.clone();
    task::spawn_local(async move {
        debug!("execute_async: inside task");
        let owned_engine = inv.engine.clone();
        let result = func(inv).await;
        debug!("execute_async: got result: {:?}", result);
        match result {
            Ok(value) => {
                debug!("execute_async: resolving promise");
                owned_promise.resolve(value).unwrap();
            }
            Err(err) => {
                debug!("execute_async: rejecting promise");
                owned_promise.reject(err.to_value(&owned_engine)).unwrap();
            }
        }
    });

    debug!("execute_async: returning promise to JS");
    promise.to_value(&engine)
}

inventory::collect!(JsCallable);

#[macro_export]
macro_rules! register_js_callable {
    ($name:expr, $func:ident) => {
        inventory::submit! {
            crate::runtime::callable::JsCallable::new(
                $name,
                $func
            )
        }
    };
}
